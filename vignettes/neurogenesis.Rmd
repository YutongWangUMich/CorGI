---
title: "Neurogenesis in the SVZ"
author: "Yutong Wang"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  comment = "#>"
)
```


```{r}
library(corgi)
library(knitr)
library(ggplot2)
library(scran) # we only need to use the multiBatchNorm function
library(scmap) # scmapCluster and highly dropped-out gene HDG feature selection
library(cowplot) # we use this to generate the multipanel plots
library(dplyr)
```

# Introduction

In this vignette, we use the _semi-supervised_ version of `corgi` applied to the neurogenesis in subventricular zone datasets:

- [Dulken et al. 2017](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5269583/)
- [Llorens-Bobadilla et al. 2015](https://www.ncbi.nlm.nih.gov/pubmed/26235341)


# Data cleaning

Load data from [Dulken et al. 2017](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5269583/)

This code is obtained from the [GitHub code for Figure 6B in Dulken et al 2017](https://github.com/bdulken/SVZ_NSC_Dulken_2/blob/master/Figure6_FigureS6/Llorens%20Projections%20_%20Figure%206B%2C%20S6A%2C%20S6B.R)

```{r, eval = F}
Llorens_allcounts<-read.table(url("https://github.com/bdulken/SVZ_NSC_Dulken_2/raw/master/Files/Llorens_counts_allgenes.txt"))

allcounts_allcells<-Llorens_allcounts

#Remove neuroblasts from Llorenss data
#allcounts_allcells_notaps<-allcounts_allcells[!grepl("tap",colnames(allcounts_allcells))]
allcounts_allcells_noblasts<-allcounts_allcells[!grepl("PSA",colnames(allcounts_allcells))]

#Remove oligodendrocytes from Llorenss data
oligos<-as.vector(read.table(url("https://raw.githubusercontent.com/bdulken/SVZ_NSC_Dulken_2/master/Files/comp_oligos.txt"))[,1])
allcounts_allcells_noblasts_nooligo<-allcounts_allcells_noblasts[,-na.omit(match(oligos,colnames(allcounts_allcells_noblasts)))]
allcounts_allcells_noblasts_nooligo_noERCC<-allcounts_allcells_noblasts_nooligo[!grepl("ERCC-",rownames(allcounts_allcells_noblasts_nooligo)),]

llorens <- allcounts_allcells_noblasts_nooligo_noERCC

llorens_cell_type <-  factor(
  unlist(
    lapply(X = colnames(llorens),
           FUN = function(x){substr(x,1,1)})
    )
  )

llorens_cell_type <- plyr::mapvalues(x = llorens_cell_type,
                                     from = c("N","t"),
                                     to = c("NSC","NPC"))

llorens <- SingleCellExperiment(assay = list(counts = as.matrix(llorens)))
llorens$cell_type1 <- llorens_cell_type
```

```{r,include = F, eval = F}
saveRDS(llorens,file = "~/CorGI_RDS/neurogenesis/llorens.rds")
```



```{r, include = F}
llorens <- readRDS(file = "~/CorGI_RDS/neurogenesis/llorens.rds")
```


Load [Llorens-Bobadilla et al. 2015](https://www.ncbi.nlm.nih.gov/pubmed/26235341) dataset

This code is obtained from the [GitHub code for Figure 1 in Dulken et al 2017](https://github.com/bdulken/SVZ_NSC_Dulken_2/blob/master/Figure1/PCA%20-%20Outliers%20Removed%20_%20Figure%201C.R). The difference between our code and theirs is that we don't filter out cell-cycle genes.

```{r, eval = F}
#Loading all high quality cells and filtering for lowly expressed genes
spec_pops<-read.table(url("https://raw.githubusercontent.com/bdulken/SVZ_NSC_Dulken_2/master/Files/AllCounts_specPops_read_gene_ERCC_filt_FINAL.txt"))

allcounts_allcells<-spec_pops

#Removing Oligodendrocytes and Outliers
oligos<-as.vector(read.table(url("https://raw.githubusercontent.com/bdulken/SVZ_NSC_Dulken_2/master/Files/STAR_oligos_updated_09232015.txt"))[,1])
allcounts_allcells_nooligo<-allcounts_allcells[,-na.omit(match(oligos,colnames(allcounts_allcells)))]

#Filtering for expressed by 5 cells at 10 counts
greaterthan0<-allcounts_allcells_nooligo>10
greaterthan0sum<-rowSums(greaterthan0)
allcounts_allcells_nooligo_genefilt<-allcounts_allcells_nooligo[greaterthan0sum>=5,]
dulken <- allcounts_allcells_nooligo_genefilt

# Overview of the Dulken dataset
dulken_cell_type <- 
  factor(
    unlist(
      lapply(X=colnames(dulken),
             FUN=function(x){strsplit(x,split = "_",fixed=T)[[1]][1]})
      )
    )

# TAP stands for transient amplifying cells, which is equivalent to neural progenitor cells here
dulken_cell_type <- plyr::mapvalues(x = dulken_cell_type,
                              from = c("aNSC", "Ast", "NPC", "qNSC", "NSC", "TAP"),
                              to = c("NSC","Ast","NPC","NSC","NSC","NPC"))


dulken <- SingleCellExperiment(assay = list(counts = as.matrix(dulken)))
dulken$cell_type1 <- dulken_cell_type
```


```{r,include = F, eval = F}
saveRDS(dulken,file = "~/CorGI_RDS/neurogenesis/dulken.rds")
```

```{r, include = F}
dulken <- readRDS(file = "~/CorGI_RDS/neurogenesis/dulken.rds")
```


# Exploratory analysis

In this section, we examine the amount of batch effects in the data.

We consider only genes in both datasets.
```{r}
shared_genes <- intersect(rownames(dulken),rownames(llorens))
length(shared_genes)
dulken <- dulken[shared_genes,]
llorens <- llorens[shared_genes,]
```

Combine the datasets and metadata
```{r}
combined <- cbind(dulken,llorens)
combined$batch <- c(rep("Dulken",ncol(dulken)),rep("Llorens",ncol(llorens)))
cell_type <- combined$cell_type1
batch <- combined$batch
```

Overview of the cell types in each dataset
```{r}
kable(table(cell_type, batch))
```


```{r}
my_shape_palette <- c(1, 16)
my_color_palette <- c("#E69F00", "#000000", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

# Wrap around qplot so to use our color settings
qplot <- function(...){
  ggplot2::qplot(...) +
    scale_shape_manual(values = my_shape_palette) +
    scale_color_manual(values = my_color_palette)
}
```


__Dimensionality reduction using all genes__

Multidimensional-scaling on Spearman rho distance matrix using all the genes results in a scatterplot with clearly separated batches

```{r}
mds <- spearman_rho_mds(counts(combined))
qplot(mds[,1],mds[,2],color = cell_type,shape = batch) + ggtitle("Spearman rho MDS using all the genes")
```


## Supervised feature selection by Dulken et al., 2017

We download the gene ranking produced by a supervised feature selection method as in [Dulken et al. 2017](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5269583/)

Note:

- The table `consensus_genes` has 101 columns, the first column is metadata
- The remainder columns are gene rankings computed by Dulken et al.
- Each column is the top 100 genes produced by one computed model.
- A gene that shows up in multiple columns means that there is a _consensus_ across multiple models that the gene should be ranked in the top 100, hence the name.

```{r, eval = F}
library("openxlsx")
consensus_genes <- read.xlsx("https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5269583/bin/NIHMS839312-supplement-7.xlsx")
dim(consensus_genes)
kable(consensus_genes[1:10,1:5]) # print a nice looking table of the top-left corner of the data
consensus_genes <- consensus_genes[,-c(1)] # remove the first column, which is metadata

all_consensus_genes <- intersect(Reduce(union, consensus_genes),
                                 shared_genes)

all_consensus_genes %>%
  sapply(function(g){
    # in how many models does g show up in?
    consensus_genes %>%
      sapply(function(model) {
        g %in% model
      }) %>%
      sum
  }) %>% 
  sort(decreasing = T) ->
  top_consensus_genes
saveRDS(top_consensus_genes, file ="~/CorGI_RDS/neurogenesis/top_consensus_genes.rds")
```

```{r, include = F}
top_consensus_genes <- readRDS(file ="~/CorGI_RDS/neurogenesis/top_consensus_genes.rds")
```


```{r}
# The vector `top_consensus_genes` counts how many times a given gene show up in the models.
head(top_consensus_genes)

# Take the genes that show up in more than 50 models. This was used in Dulken et al., 2017.
consensus34 <- names(which(top_consensus_genes>50))

# There are 34 genes that show up in more than 50% of the models. Just to check.
length(consensus34)
```

# Semi-supervised CorGI 

Wwith the 34 consensus genes as markers

```{r,eval = F}
set.seed(0)
corgi_output_neurogenesis <- run_corgi(dulken, llorens, must_have_genes = consensus34)
```

```{r,eval = F,include=F}
devtools::use_data(corgi_output_neurogenesis,overwrite = T)
```

```{r,include=F}
data("corgi_output_neurogenesis")
```

## Dimensionality reduction using MDS
```{r}
corgi_gene_set <- select_top_corgi_genes(corgi_output_neurogenesis,n = 100, phase_use = 1)
length(corgi_gene_set)

gene_set <- union(corgi_gene_set,consensus34)

mds <- spearman_rho_mds(counts(combined)[gene_set,])
qplot(mds[,1],mds[,2],color = cell_type,shape = batch)
```


# Recreating the paper figure

In this section, we recreate the figures in our paper, i.e., comparing with highly dropped-out genes.

## Normalize the datasets

We use the batch normalization of scran so that we can run the highly dropped-out gene selection.
```{r}
out <- scran::multiBatchNorm(dulken,llorens) # the output has logcounts
dulken <- out[[1]]
llorens <- out[[2]]
```



```{r}
HDG_ranking <- function(sce){
  rowData(sce)$feature_symbol <- rownames(sce)
  sce <- selectFeatures(sce,suppress_plot = F)
  return(rownames(sce)[order(rowData(sce)[["scmap_scores"]],decreasing = T,na.last = T)])
}

n <- length(union(corgi_gene_set,consensus34))

gene_sets <- get_compared_gene_sets(
  batch1_top_genes = HDG_ranking(dulken),
  batch1_name = "HDG(Dulken)",
  batch2_top_genes = HDG_ranking(llorens),
  batch2_name = "HDG(Llorens)",
  desired_size = n,
  marker_genes = consensus34)

gene_sets[["C134"]] <- names(top_consensus_genes)[1:n]

gene_sets[["CorGI"]] <- union(corgi_gene_set,consensus34)

gene_sets <- gene_sets[c(6,5,4,3,2,1)]
lapply(gene_sets, length)
```

scmapCluster parameters

```{r}
rowData(dulken)$feature_symbol <- rownames(dulken)
rowData(llorens)$feature_symbol <- rownames(llorens)

threshold <- 0.3
```


Use the Dulken dataset (excluding the astrocytes) to predict the cell types in Llorens

Using the CorGI gene set
```{r}
gene_set <- gene_sets[["CorGI"]]
corgi::run_scmap(
  query = llorens,
  ref = dulken[,dulken$cell_type1!="Ast"],
  gene_set = gene_set,
  threshold = threshold,
  dnn = c("Prediction","Truth")
) -> scmap_output

kable(scmap_output$table)

kable(scmap_output$overall)
```

Using the C134 gene set
```{r}
gene_set <- gene_sets[["C134"]]
corgi::run_scmap(
  query = llorens,
  ref = dulken[,dulken$cell_type1!="Ast"],
  gene_set = gene_set,
  threshold = threshold
) -> scmap_output

kable(scmap_output$table)

kable(scmap_output$overall)
```

Using the _Union_ gene set
```{r}
gene_set <- gene_sets[["Union"]]
corgi::run_scmap(
  query = llorens,
  ref = dulken[,dulken$cell_type1!="Ast"],
  gene_set = gene_set,
  threshold = threshold
) -> scmap_output

kable(scmap_output$table)

kable(scmap_output$overall)
```

Repeat the result above but for all gene sets sweeping over thresholds in $\{0.1, 0.2,...,0.9\}$

```{r}
comparison_results <-
  run_cluster_coherence_comparison(
    query = llorens,
    reference = dulken[,dulken$cell_type1!="Ast"]
  )

cluster_coherence_plot <- plot_cluster_coherence_comparison(comparison_results) +
    ggtitle("Reference = Dulken (no astrocytes)\nQuery = Llorens-Bobadilla")
cc_plts <- list()
cluster_coherence_plot -> cc_plts[[1]]
cc_plts[[1]]
```

Swap the query and reference

```{r}
comparison_results <-
  run_cluster_coherence_comparison(
    query = dulken[,dulken$cell_type1!="Ast"],
    reference = llorens
  )
plot_cluster_coherence_comparison(comparison_results) +
  ggtitle("Reference = Llorens-Bobadilla, \nQuery = Dulken (no astrocytes)") -> cc_plts[[2]]
cc_plts[[2]]
```


```{r}
comparison_results <-
  run_cluster_coherence_comparison(
    query = llorens,
    reference = dulken
  )
plot_cluster_coherence_comparison(comparison_results) +
  ggtitle("Reference = Dulken, \nQuery = Llorens-Bobadilla") -> cc_plts[[3]]

cc_plts[[3]]
```




```{r}
comparison_results <-
  run_cluster_coherence_comparison(
    query = dulken,
    reference = llorens
  )
plot_cluster_coherence_comparison(comparison_results) +
  ggtitle("Reference = Llorens-Bobadilla,\nQuery = Dulken") -> cc_plts[[4]]

cc_plts[[4]]
```


```{r, include = F}

cc_plts %>%
  lapply(function(p)
    p + theme(legend.position = "none")
    ) -> cc_plts
cc_plts[["labels"]] <- LETTERS[1:4]

cc_plts <- lapply(cc_plts, function(p) p + ylim(c(0,1)))
cc_lgnd <- get_legend(cc_plts[[1]] +
                        theme(legend.position = "bottom"))

plot_grid(do.call(what = plot_grid,args = cc_plts),
          cc_lgnd,
          nrow = 2,
          rel_heights = c(10,1)) -> kappa_plt


ggsave(filename = "neurogenesis_kappa.eps",device = "eps",plot = kappa_plt, path = "~/CorGI_figures/neurogenesis",width = 8,height = 8)
```

```{r}
embeddings_mds <- 
  lapply(
    X = gene_sets,
    FUN = function(gene_set) {
      D <- sqrt((1 - cor(counts(combined)[gene_set, ], method = "spearman")) / 2)
      return(cmdscale(D, k = 2))
    }
  )
```


```{r}
emb_name <- "MDS"
embeddings <- embeddings_mds
get_scatterplots(embeddings,
                 combined$batch,
                 combined$cell_type1) -> dr_plots
# 

# dr_plots[[length(dr_plots)+1]] <- legends

dr_plots[["nrow"]] <- 2

dr_plots[["labels"]] <- c("A","B","C","D","E","F")

do.call(plot_grid,dr_plots) -> top_panel
top_panel
```

```{r}
plot_grid(
  plot_grid(
    get_axes_legend(emb_name),
    get_shape_legend(batch, my_shape_palette)
  ),
  get_color_legend(cell_type, my_color_palette),
  nrow = 2) -> legends
```




```{r,fig.height=2,fig.width=6}
plot_grid(
  legends,
  cluster_coherence_plot + theme(plot.title = element_text(size=10)),
  nrow = 1,
  rel_widths = c(1,2),
  labels = c("","G")) -> bottom_panel

bottom_panel
```




```{r,fig.width=6,fig.height=6}
panel_plot_mds <- plot_grid(top_panel,bottom_panel,nrow=2,rel_heights = c(2,1))
panel_plot_mds
```


```{r, include = F}
ggsave(filename = "neurogenesis_MDS.eps",device = "eps",plot = panel_plot_mds,path = "~/CorGI_figures/neurogenesis",width = 8,height = 8)
```


```{r}
embeddings_mnn_pca <- 
  lapply(
    X = gene_sets,
    FUN = function(gene_set) {
      mnn.out <- mnnCorrect(logcounts(dulken[gene_set,]),logcounts(llorens[gene_set,]))
      t.mnn <<- as.matrix(t(do.call(cbind, mnn.out$corrected)))
      pca.mnn <- prcomp(t.mnn, rank=2)
      return(pca.mnn$x)
    }
  )
```



```{r}
emb_name <- "MNNPC"
embeddings <- embeddings_mnn_pca
get_scatterplots(embeddings,
                 batch,
                 cell_type) -> dr_plots

dr_plots[["nrow"]] <- 2

dr_plots[["labels"]] <- c("A","B","C","D","E","F")

do.call(plot_grid,dr_plots) -> top_panel
top_panel
```

```{r}
plot_grid(
  get_axes_legend(emb_name),
  get_shape_legend(batch, my_shape_palette),
  get_color_legend(cell_type, my_color_palette),
  nrow = 3) -> legends
```







```{r,fig.width=8,fig.height=5}
panel_plot_mnn <- plot_grid(top_panel,legends,nrow=1,rel_widths = c(6,1))
panel_plot_mnn
```


```{r, include = F}

ggsave(filename = "neurogenesis_MNN.eps",device = "eps",plot = panel_plot_mnn,path = "~/CorGI_figures/neurogenesis",width = 8,height = 5)
```


