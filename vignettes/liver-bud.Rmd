---
title: "Liver bud development"
author: "Yutong Wang"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  comment = "#>"
)
```



```{r}
library(corgi) 
library(knitr) # for printing nice looking tables
library(ggplot2) # for creating pretty plots
library(cowplot) # for creating panel of plots
library(dplyr) # for pretty code
library(forcats) # for concatenating factors
library(scmap) # for the compared feature selection method
library(scran)
```

# Introduction

We analyze the liver bud dataset from [Camp et al 2017](https://www.nature.com/articles/nature22796).

Everything below is totally self-contained: you can copy-paste word for word and it will run. The single-line code block in section _CorGI unsupervised feature selection_ takes one hour to run. Everything else in total takes under one minute.

This vignette contains long sections headed by _Reproducing paper figures_. These sections are not necessary for using CorGI. To see a more user-friendly pipeline for applying CorGI to your research, see [Get Started](https://yutongwangumich.github.io/corgi/articles/corgi.html).

The section under _Exploratory analysis_ (and in particular, normalization by making the library sizes comparable across batches) is also not necessary to use CorGI. In fact, it makes no difference whether the counts are integers, log-transformed, TPM, FPKM, etc. 


# Data cleaning


```{r, eval = F}
con <- gzcon(
  url("ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE81nnn/GSE81252/suppl/GSE81252_data.cast.log2.liverbud.csv.gz")
  )
txt <- readLines(con)
liverbud <- read.csv(file = textConnection(txt))

# The first three columns are metadata while the rest are the log2 expressions
metadata <- liverbud[,1:3]
counts <- t(as.matrix(liverbud[,4:ncol(liverbud)]))

colnames(counts) <- metadata$cell_id
rownames(metadata) <- metadata$cell_id

# The column "assignment_LB" contains both the lineage and batch information
# IN = input cell lines, LB = liver bud
metadata$LB_status <- 
  unlist(lapply(X = metadata$assignment_LB,
                FUN = function(x) ifelse(test = grepl("LB",x),yes = "Liver_bud",no = "Input")
                ))
# EC = endothelial cells, HE = hepatic endoderm, MC = mesenchymal cells
metadata$lineage <- 
  factor(unlist(
    lapply(X = metadata$assignment_LB,
           FUN = function(x) strsplit(as.character(x),split = "-",fixed = T)[[1]][1])
    ))

plyr::mapvalues(x = metadata$lineage,
                from = levels(metadata$lineage),
                to = c("Endothelial","Hepatic","Mesenchymal")) -> metadata$lineage


camp <- SingleCellExperiment(assays = list(logcounts = counts),colData = metadata)
```


```{r, eval = F, include = F}
saveRDS(camp,file = "~/CorGI_RDS/liver_bud/camp.rds")
```


```{r, include = F}
camp <- readRDS(file = "~/CorGI_RDS/liver_bud/camp.rds")
```


# Exploratory analysis



Convert to `SingleCellExperiment` objects
```{r}
IN <- camp[,camp$LB_status=="Input"]
LB <- camp[,camp$LB_status=="Liver_bud"]
```

```{r}
gene_loadings <- CCSpearman_GeneLoading(logcounts(IN), logcounts(LB), k = 3)

union(
  top_n_genes((gene_loadings^2)[,2],250),
  top_n_genes((gene_loadings^2)[,3],250)
  ) -> 
  cca_genes
```


Normalization by making the library sizes comparable across batches
```{r}
out <- scran::multiBatchNorm(IN,LB,assay.type = "logcounts")
IN_norm <- out[[1]]
LB_norm <- out[[2]]
rm(out)
```

Combine the datasets
```{r}
combined <- cbind(IN,LB)
combined$batch <- c(rep("Input",ncol(IN)),rep("Liver bud",ncol(LB)))
lineage <- combined$lineage
batch <- combined$batch
```

Wrapper around qplot for visualization
```{r}
my_color_palette <- c("#000000", "#E69F00", "#56B4E9", "#999999", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
my_shape_palette <- c(16,1,2)
qplot <- function(...){
  ggplot2::qplot(...) +
  scale_color_manual(values = my_color_palette) + 
  scale_shape_manual(values = my_shape_palette)
}
```

## PC plot using all the genes

```{r}
pc <- prcomp(t(logcounts(combined)),rank. = 2)$x
qplot(pc[,1],pc[,2],color = lineage,shape = batch)
```


# CorGI unsupervised feature selection

```{r, eval = F}
set.seed(0)
corgi_output_liver_bud <- run_corgi(logcounts(IN),logcounts(LB))
```

```{r, eval = F, include= F}
devtools::use_data(corgi_output_liver_bud,overwrite = T)
```

```{r,include = F}
data("corgi_output_liver_bud")
```

## Selecting the top CorGI genes

```{r}
corgi_gene_set <- union(
  select_top_corgi_genes(corgi_output_liver_bud,250,SVG_use = 2),
  select_top_corgi_genes(corgi_output_liver_bud,250,SVG_use = 3))
```



## PCA on CorGI genes

```{r}
pc <- prcomp(t(logcounts(combined)[corgi_gene_set,]),rank. = 2)$x
qplot(pc[,1],pc[,2],color = lineage,shape = batch)
```




# Reproducing paper figures

Gene sets to compare CorGI against


```{r}
HDG_ranking <- function(sce){
  rowData(sce)$feature_symbol <- rownames(sce)
  sce <- selectFeatures(sce,suppress_plot = F)
  return(rownames(sce)[order(rowData(sce)[["scmap_scores"]],decreasing = T,na.last = T)])
}

gene_sets <- get_compared_gene_sets(
  batch1_top_genes = HDG_ranking(IN),
  batch1_name = "HDG(Input)",
  batch2_top_genes = HDG_ranking(LB),
  batch2_name = "HDG(Liver bud)",
  desired_size = length(corgi_gene_set)
)

gene_sets[["CorGI"]] <- corgi_gene_set

names(gene_sets)
```

Reorder the gene sets
```{r}
gene_sets <- gene_sets[c(5,1,2,3,4)]
lapply(gene_sets, length)
```


```{r}
embeddings_mds <- 
  lapply(
    X = gene_sets,
    FUN = function(gene_set) {
      D <- sqrt((1 - cor(logcounts(combined)[gene_set, ], method = "spearman")) / 2)
      return(cmdscale(D, k = 2))
    }
  )
```


```{r}
emb_name <- "MDS"
embeddings <- embeddings_mds
get_scatterplots(embeddings,
                 batch,
                 lineage) -> dr_plots

plot_grid(
  plot_grid(
    get_axes_legend(emb_name),
    get_shape_legend(batch, my_shape_palette)
  ),
  get_color_legend(lineage, my_color_palette),
  nrow = 2) -> legends

dr_plots[[length(dr_plots)+1]] <- legends

dr_plots[["nrow"]] <- 2

dr_plots[["labels"]] <- c("A","B","C","D","E","")

do.call(plot_grid,dr_plots) -> top_panel
top_panel
```


scmapCluster parameters

```{r}
rowData(IN_norm)$feature_symbol <- rownames(IN_norm)
rowData(LB_norm)$feature_symbol <- rownames(LB_norm)
IN_norm$cell_type1 <- lineage[batch == "Input"]
LB_norm$cell_type1 <- lineage[batch == "Liver bud"]

query <- LB_norm
reference <- IN_norm
threshold <- 0.3
```


```{r}
gene_set <- gene_sets[["CorGI"]]
corgi::run_scmap(
  query = query,
  ref = reference,
  gene_set = gene_set,
  threshold = threshold
)
```



Testing 

```{r}
comparison_results <-
  run_mapping_accuracy_comparison(
    query = IN_norm,
    reference = LB_norm,
    gene_sets = gene_sets
  )

cluster_coherence_plot_1 <- plot_mapping_accuracy_comparison(comparison_results) +
    ggtitle("Reference = Liver bud \nQuery = Input")

cluster_coherence_plot_1
```


```{r}
comparison_results <-
  run_mapping_accuracy_comparison(
    query = LB_norm,
    reference = IN_norm,
    gene_sets = gene_sets
  )
cluster_coherence_plot_2 <- plot_mapping_accuracy_comparison(comparison_results) +
    ggtitle("Reference = Input \nQuery = Liver bud")

cluster_coherence_plot_2
```

```{r}
plot_grid(cluster_coherence_plot_1 + 
            theme(legend.position = "none") + 
            theme(plot.title = element_text(size=10)) + ylim(c(0,1)),
          cluster_coherence_plot_2 + 
            theme(legend.position = "none") + 
            theme(plot.title = element_text(size=10)) + ylim(c(0,1)),
          get_legend(cluster_coherence_plot_1),
          ncol = 3,
          labels = c("F","G"),
          rel_widths = c(2,2,1)) -> bottom_panel

```


```{r,include=F}
liver_bud_panel <- plot_grid(top_panel,bottom_panel,nrow=2,rel_heights = c(2,1))
ggsave(filename = "liver_bud.eps",device = "eps",plot = liver_bud_panel, path = "~/CorGI_figures/liver_bud",width = 8,height = 8)
```




# Out of sample alignment of human liver cells

In the previous sections, we ran CorGI feature selection on the input and liver bud cells. We consider the _primary_ human liver cells sequenced also by Camp et al. We analyze how genes obtained from the previous section can be used to gain insight in the new data.

Confer [Camp et al. 2017, Figure 3b](https://www.nature.com/articles/nature22796#f3) for the cluster labels of the primary human liver cells.


## Data cleaning
```{r, eval = F}
con <- gzcon(
  url("ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE96nnn/GSE96981/suppl/GSE96981_data.human.liver.csv.gz")
  )
txt <- readLines(con)
human_liver <- read.csv(file = textConnection(txt))

# The first 13 columns are metadata
colnames(human_liver)[1:13]
mdat <- human_liver[,1:13]


# The remaining are genes
colnames(human_liver)[14:20]
counts <- t(as.matrix(human_liver[,14:ncol(human_liver)]))
colnames(counts) <- mdat$cell_id


mdat$ident <- as.factor(mdat$ident)
qplot(mdat$tSNE_1,mdat$tSNE_2,color = mdat$ident)

# Just to double check...
mdat$cell_type_raw <- 
  plyr::mapvalues(mdat$ident,
                  from = 1:7,
                  to = c("Lymphoblast",
                         "Erythroblast",
                         "Adult hepatocyte",
                         "Mesenchymal",
                         "Endothelial",
                         "Fetal hepatocyte",
                         "Kupffer"))

mdat_ann <- mdat[which(!duplicated(mdat$cell_type_raw)),]
mdat_ann <- mdat_ann[order(mdat_ann$cell_type_raw),]
mdat_ann[,4] <- mdat_ann[,4] + 3
mdat_ann[,3] <- mdat_ann[,3] + 1
qplot(mdat$tSNE_1,mdat$tSNE_2,color = mdat$cell_type_raw) +
  annotate("text", x = mdat_ann$tSNE_1, y = mdat_ann$tSNE_2, font = 1, size = 4,
           label = levels(mdat_ann$cell_type_raw))

# Collapse some of the cell types for visualization
mdat$lineage_show <- 
  plyr::mapvalues(mdat$ident,
                  from = 1:7,
                  to = c("Other",
                         "Other",
                         "Adult hepatocyte",
                         "Mesenchymal",
                         "Endothelial",
                         "Fetal hepatocyte",
                         "Other"))
# Collapse _Adult hepatocyte_ and _Immature hepatocyte_ to simply _Hepatic_ for the KNN classification part
mdat$lineage_pred <- 
  plyr::mapvalues(mdat$ident,
                  from = 1:7,
                  to = c("unassigned",
                         "unassigned",
                         "Hepatic",
                         "Mesenchymal",
                         "Endothelial",
                         "Hepatic",
                         "unassigned"))
HL <- SingleCellExperiment(assays = list(logcounts = counts),colData = mdat)
```

```{r, eval = F, include = F}
saveRDS(HL,file = "~/CorGI_RDS/liver_bud/HL.rds")
```

```{r, include = F}
HL <- readRDS(file = "~/CorGI_RDS/liver_bud/HL.rds")
```


# Reproducing paper figures

Combine the datasets and normalize
```{r}
shared_genes <- intersect(rownames(IN),rownames(HL))
IN <- IN[shared_genes,]
LB <- LB[shared_genes,]
HL <- HL[shared_genes,]
```

```{r}
out <- scran::multiBatchNorm(IN,LB,HL,assay.type = "logcounts")
IN <- out[[1]]
LB <- out[[2]]
HL <- out[[3]]

lineage_show <- fct_c(IN$lineage,LB$lineage,HL$lineage_show)
lineage_pred <- fct_c(IN$lineage,LB$lineage,HL$lineage_pred)
batch <- c(rep("Input",ncol(IN)),rep("Liver bud",ncol(LB)),rep("Primary",ncol(HL)))
```



```{r}
embeddings_mnn <- 
  lapply(
    X = gene_sets,
    FUN = function(gene_set) {
      mnn.out <- mnnCorrect(logcounts(IN[gene_set,]),
                            logcounts(LB[gene_set,]),
                            logcounts(HL[gene_set,]))
      t.mnn <- as.matrix(t(do.call(cbind, mnn.out$corrected)))
      pca.mnn <- prcomp(t.mnn, rank=2)
      return(pca.mnn$x)
    }
  )
```


Shorten the names

```{r}
before <- unique(lineage_show)
plyr::mapvalues(
  x = lineage_show,
  from = unique(lineage_show),
  to = c("Hep.","End.","Mes.", "Fetal hep.", "Other", "Adult hep.")
) -> lineage_show

data.frame(`Long name` = before,`Short name` = unique(lineage_show))
```


```{r}
emb_name <- "MNNPC"
embeddings <- embeddings_mnn
get_scatterplots(embeddings,
                 batch,
                 lineage_show) -> dr_plots

plot_grid(
  plot_grid(
    get_axes_legend(emb_name),
    get_shape_legend(batch,my_shape_palette)
  ),
  get_color_legend(lineage_show,my_color_palette,ncol = 2),
  nrow = 2) -> legends

dr_plots[[length(dr_plots)+1]] <- legends
dr_plots[["nrow"]] <- 2
dr_plots[["labels"]] <- c("A","B","C","D","E","")

do.call(plot_grid,dr_plots) -> top_panel
top_panel

```



```{r}
IN_LB <- cbind(IN,LB)
IN_LB$cell_type1 <- lineage_pred[batch != "Primary"]
HL$cell_type1 <- lineage_pred[batch == "Primary"]
IN$cell_type1 <- lineage_pred[batch == "Input"]
LB$cell_type1 <- lineage_pred[batch == "Liver bud"]
rowData(IN_LB)$feature_symbol <- rownames(IN_LB)
rowData(HL)$feature_symbol <- rownames(HL)
rowData(IN)$feature_symbol <- rownames(IN)
rowData(LB)$feature_symbol <- rownames(LB)

threshold <- 0.3
```


```{r}
comparison_results <-
  run_mapping_accuracy_comparison(
    query = IN_LB,
    reference = HL,
    gene_sets = gene_sets
  )

cluster_coherence_plot_3 <- plot_mapping_accuracy_comparison(comparison_results) +
    ggtitle("Reference = Human liver \nQuery = Liver bud & input cell lines")

cluster_coherence_plot_3
```

```{r, eval = F, include = F}
HL$cell_type1 <- HL$cell_type_raw
IN$cell_type1 <- lineage_show[batch == "Input"]
LB$cell_type1 <- lineage_show[batch == "Liver bud"]

IN_LB <- cbind(IN,LB)
# IN_LB <- 
  # IN_LB$assignment_LB
# old <- HL$cell_type_raw
HL$cell_type_raw <- factor(HL$cell_type_raw,levels = c("Endothelial","Adult hepatocyte","Fetal hepatocyte","Mesenchymal","Lymphoblast","Erythroblast","Kupffer"),ordered = T)


IN_LB$cell_type1 <- IN_LB$assignment_LB
                             

run_scmap(query = IN_LB,
          ref = HL,
          gene_set = gene_sets[["CorGI"]],
          threshold = 0.3,
          dnn = c("Prediction","Truth")) -> result

result$table[rowSums(result$table)!=0,colSums(result$table)!=0] -> table_show
table_show

run_scmap(query = IN_LB,
          ref = HL,
          gene_set = gene_sets[["Intersection"]],
          threshold = 0.3,
          dnn = c("Prediction","Truth")) -> result
result$table[rowSums(result$table)!=0,colSums(result$table)!=0] -> table_show
table_show
```


```{r}

# unique(HL$cell_type1)
comparison_results <-
  run_mapping_accuracy_comparison(
    query = HL,
    reference = IN_LB,
    gene_sets = gene_sets
  )

cluster_coherence_plot_4 <- plot_mapping_accuracy_comparison(comparison_results) +
    ggtitle("Reference = Liver bud & input cell lines \nQuery = Human liver")

cluster_coherence_plot_4

```

```{r}
# get_legend(cluster_coherence_plot_3)

plot_grid(cluster_coherence_plot_3 + 
            theme(legend.position = "none") + 
            theme(plot.title = element_text(size=10))+ ylim(c(0,1)),
          cluster_coherence_plot_4 + 
            theme(legend.position = "none") + 
            theme(plot.title = element_text(size=10))+ ylim(c(0,1)),
          get_legend(cluster_coherence_plot_3),
          ncol = 3,
          labels = c("F","G"),
          rel_widths = c(2,2,1)) -> bottom_panel
```


```{r,include=F}
human_liver_panel <- plot_grid(top_panel,bottom_panel,nrow=2,rel_heights = c(2,1))

ggsave(filename = "human_liver.eps",device = "eps",plot = human_liver_panel, path = "~/CorGI_figures/liver_bud",width = 8,height = 8)
```


```{r}

list(cluster_coherence_plot_1,
     cluster_coherence_plot_2,
     cluster_coherence_plot_3,
     cluster_coherence_plot_4) %>%
  lapply(function(p)
    p + theme(legend.position = "none") + ylim(c(0,1))
    ) -> cc_plts
cc_plts[["labels"]] <- LETTERS[1:4]
cc_lgnd <- get_legend(cluster_coherence_plot_1 +
                        theme(legend.position = "bottom"))

plot_grid(do.call(what = plot_grid,args = cc_plts),
          cc_lgnd,
          nrow = 2,
          rel_heights = c(10,1)) -> kappa_plt


ggsave(filename = "kappa.eps",device = "eps",plot = kappa_plt, path = "~/CorGI_figures/liver_bud",width = 8,height = 8)

```

